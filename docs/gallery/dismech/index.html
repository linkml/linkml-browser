<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized Faceted Search</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Helvetica Neue', sans-serif;
            background: linear-gradient(170deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #fafafa;
            border-radius: 4px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .header {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 40px 30px;
            text-align: left;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -10%;
            width: 50%;
            height: 200%;
            background: rgba(255,255,255,0.05);
            transform: rotate(35deg);
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
            position: relative;
        }

        .header p {
            opacity: 0.95;
            font-size: 1rem;
            font-weight: 400;
            position: relative;
        }

        .search-container {
            padding: 24px 30px;
            background: white;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .search-box {
            flex: 1;
            padding: 12px 16px;
            font-size: 15px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            outline: none;
            transition: all 0.2s ease;
            background: white;
        }

        .search-box:focus {
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }

        .performance-info {
            font-size: 13px;
            color: #6b7280;
            font-weight: 500;
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .sidebar {
            width: 280px;
            background: #f9fafb;
            padding: 24px;
            border-right: 1px solid #e5e7eb;
        }

        .facet-group {
            margin-bottom: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            overflow: hidden;
            background: white;
        }

        .facet-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: white;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.15s ease;
            border-bottom: 1px solid #f3f4f6;
        }

        .facet-header:hover {
            background: #f9fafb;
        }

        .facet-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: #111827;
            margin: 0;
            letter-spacing: -0.2px;
        }

        .facet-toggle {
            font-size: 0.9rem;
            color: #10b981;
            transition: transform 0.2s ease;
            font-weight: 600;
        }

        .facet-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .facet-content {
            padding: 15px 20px;
            max-height: 400px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .facet-content.collapsed {
            max-height: 0;
            padding: 0 20px;
            overflow: hidden;
        }

        .facet-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            padding: 7px 12px;
            border-radius: 4px;
            transition: all 0.15s ease;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .facet-item:hover {
            background: #f3f4f6;
        }

        .facet-item.active {
            background: #10b981;
            color: white;
        }

        .facet-checkbox {
            margin-right: 10px;
            width: 16px;
            height: 16px;
            accent-color: #10b981;
            cursor: pointer;
        }

        .facet-count {
            margin-left: auto;
            background: #f3f4f6;
            color: #6b7280;
            padding: 2px 7px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            min-width: 24px;
            text-align: center;
        }

        .facet-item.active .facet-count {
            background: rgba(255,255,255,0.25);
            color: white;
        }

        .results-area {
            flex: 1;
            padding: 24px;
            background: white;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e5e7eb;
        }

        .results-count {
            font-size: 1rem;
            color: #374151;
            font-weight: 500;
        }

        .clear-filters {
            background: #ef4444;
            color: white;
            border: none;
            padding: 7px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.15s ease;
        }

        .clear-filters:hover {
            background: #dc2626;
            transform: translateY(-1px);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }

        .result-card {
            background: #fafafa;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
            overflow: hidden;
            border: 1px solid #e5e7eb;
            padding: 16px;
        }

        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            border-color: #10b981;
        }

        .field-display {
            margin-bottom: 12px;
        }

        .field-label {
            font-weight: 600;
            color: #6b7280;
            margin-right: 8px;
            display: inline-block;
            min-width: 80px;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .field-value {
            color: #111827;
            font-size: 0.9rem;
        }

        .array-values {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }

        .array-item {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            color: #065f46;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            border: 1px solid #6ee7b7;
        }

        .no-results {
            text-align: center;
            padding: 60px 20px;
            color: #718096;
            grid-column: 1 / -1;
        }

        .load-more-container {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px;
        }

        .load-more-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 12px 32px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
        }

        .load-more-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);
        }

        .load-more-info {
            margin-top: 8px;
            font-size: 13px;
            color: #6b7280;
        }

        .facet-show-more {
            padding: 8px 12px;
            margin-top: 8px;
            background: #f3f4f6;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #10b981;
            font-weight: 600;
            width: 100%;
            transition: all 0.15s ease;
        }

        .facet-show-more:hover {
            background: #e5e7eb;
        }

        /* Numeric filter styles - Range Slider */
        .numeric-filter-container {
            padding: 15px 10px 25px 10px;
        }

        .range-slider-wrapper {
            position: relative;
            height: 40px;
            margin-bottom: 8px;
        }

        .range-slider-track {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            transform: translateY(-50%);
        }

        .range-slider-range {
            position: absolute;
            top: 50%;
            height: 6px;
            background: #10b981;
            border-radius: 3px;
            transform: translateY(-50%);
        }

        .range-slider-handle {
            position: absolute;
            top: 50%;
            width: 18px;
            height: 18px;
            background: white;
            border: 2px solid #10b981;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            z-index: 2;
            transition: box-shadow 0.15s ease, transform 0.1s ease;
        }

        .range-slider-handle:hover {
            box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.2);
        }

        .range-slider-handle:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.25);
        }

        .range-slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        .range-slider-label {
            font-weight: 500;
        }

        .range-slider-clear {
            position: absolute;
            top: -2px;
            right: 0;
            font-size: 12px;
            color: #10b981;
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 6px;
            font-weight: 500;
        }

        .range-slider-clear:hover {
            text-decoration: underline;
        }

        .results-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .curation-action-btn {
            background: #0ea5e9;
            color: white;
            border: none;
            padding: 7px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.15s ease;
        }

        .curation-action-btn:hover {
            background: #0284c7;
            transform: translateY(-1px);
        }

        .curation-action-btn.secondary {
            background: #64748b;
        }

        .curation-action-btn.secondary:hover {
            background: #475569;
        }

        .curation-panel {
            margin-top: 12px;
            padding: 12px;
            border-top: 1px solid #e5e7eb;
            background: #f8fafc;
        }

        .curation-header {
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #64748b;
            margin-bottom: 8px;
        }

        .curation-field {
            margin-bottom: 10px;
        }

        .curation-section {
            margin-bottom: 8px;
        }

        .curation-label {
            display: block;
            font-size: 0.8rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 4px;
        }

        .curation-input,
        .curation-select,
        .curation-textarea {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.85rem;
            background: white;
        }

        .curation-textarea {
            min-height: 70px;
            resize: vertical;
        }

        .curation-multiselect {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .curation-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.82rem;
            color: #374151;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            padding: 4px 8px;
        }

        .curation-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .curation-status {
            font-size: 0.78rem;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 999px;
            background: #e2e8f0;
            color: #475569;
        }

        .curation-status.pending { background: #e2e8f0; color: #475569; }
        .curation-status.draft { background: #fde68a; color: #92400e; }
        .curation-status.submitted { background: #bbf7d0; color: #166534; }
        .curation-status.discarded { background: #fecaca; color: #991b1b; }

        .curation-decorators {
            margin-top: 6px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .curation-thumb,
        .curation-rating-star {
            border: 1px solid #d1d5db;
            background: white;
            color: #374151;
            font-size: 0.85rem;
            padding: 4px 6px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .curation-thumb.active,
        .curation-rating-star.active {
            background: #10b981;
            color: white;
            border-color: #10b981;
        }

        .curation-rating {
            display: flex;
            gap: 4px;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 id="appTitle">‚ö° Generic Faceted Search</h1>
            <p id="appDescription">Schema-driven search with high performance</p>
        </div>

        <div class="search-container">
            <input type="text" id="searchBox" class="search-box" placeholder="Search products...">
            <div class="performance-info" id="performanceInfo">Ready</div>
        </div>

        <div class="main-content">
            <div class="sidebar" id="facetsSidebar">
                <!-- Facets will be generated here -->
            </div>

            <div class="results-area">
                <div class="results-header">
                    <div class="results-count" id="resultsCount">Loading...</div>
                    <div class="results-actions">
                        <button class="curation-action-btn secondary" id="openDataset">Open Dataset</button>
                        <button class="curation-action-btn" id="exportAnnotations">Export Annotations</button>
                        <button class="curation-action-btn secondary" id="importAnnotations">Import Annotations</button>
                        <input type="file" id="importAnnotationsFile" accept="application/json" style="display: none;">
                        <button class="clear-filters" id="clearFilters">Clear All Filters</button>
                    </div>
                </div>
                <div class="results-grid" id="resultsGrid"></div>
            </div>
        </div>
    </div>

    <!-- Load external data -->
    <script src="data.js"></script>
    <script src="schema.js"></script>

    <script>
        class OptimizedFacetedSearch {
            constructor(data, schema) {
                console.log('üèóÔ∏è OptimizedFacetedSearch constructor called');
                console.log('Data sample:', data.slice(0, 2));
                console.log('Schema:', schema);
                
                this.originalData = data;
                this.schema = schema;
                this.currentFilters = {};
                this.currentQuery = '';

                // Track collapsed facets
                this.collapsedFacets = new Set();

                // Pagination settings
                this.itemsPerPage = schema.itemsPerPage || 50;
                this.displayedCount = this.itemsPerPage;
                this.currentFilteredData = [];

                // Facet pagination settings
                this.facetItemsToShow = schema.facetItemsToShow || 10;
                this.expandedFacets = new Set();
                this.currentFacetCounts = null;

                // Curation state
                this.curationEnabled = false;
                this.curationFields = [];
                this.annotations = {};
                this.recordIdField = null;
                this.recordIndexById = new Map();
                this.curatorId = null;
                this.datasetHash = null;
                this.curationLayout = 'inline';
                this.allowedStatuses = ['pending', 'draft', 'submitted', 'discarded'];
                this.initializeCuration();
                
                try {
                    console.log('üìö Building search index...');
                    this.searchIndex = this.buildSearchIndex();
                    console.log('‚úÖ Search index built:', this.searchIndex.size, 'tokens');
                    
                    console.log('üè∑Ô∏è Building facet index...');
                    this.facetIndex = this.buildFacetIndex();
                    console.log('‚úÖ Facet index built');
                    
                    console.log('üéß Setting up event listeners...');
                    this.setupEventListeners();
                    
                    console.log('üîç Performing initial search...');
                    this.search();
                    console.log('‚úÖ Constructor complete');
                } catch (error) {
                    console.error('‚ùå Error in constructor:', error);
                    throw error;
                }
            }

            initializeCuration() {
                const hasCurationFields = Array.isArray(this.schema.curationFields) && this.schema.curationFields.length > 0;
                const hasDecorators = Array.isArray(this.schema.displayFields) &&
                    this.schema.displayFields.some(field => Array.isArray(field.decorators) && field.decorators.length > 0);
                this.curationEnabled = hasCurationFields || hasDecorators;

                if (!this.curationEnabled) {
                    this.toggleCurationUI(false);
                    return;
                }

                if (!this.schema.recordIdField) {
                    console.warn('Curation enabled but recordIdField is missing. Disabling curation.');
                    this.curationEnabled = false;
                    this.toggleCurationUI(false);
                    return;
                }

                this.recordIdField = this.schema.recordIdField;
                this.curationLayout = (this.schema.curation && this.schema.curation.layout) || 'inline';
                this.curationFields = Array.isArray(this.schema.curationFields) ? this.schema.curationFields : [];
                if (this.curationLayout === 'split') {
                    console.warn('Split curation layout is not implemented yet. Falling back to inline.');
                    this.curationLayout = 'inline';
                }

                this.buildRecordIndex();
                this.datasetHash = this.computeDatasetHash();
                this.annotations = this.loadAnnotationsFromStorage();
                this.ensureStatusFacet();
                this.toggleCurationUI(true);
            }

            toggleCurationUI(enabled) {
                const exportBtn = document.getElementById('exportAnnotations');
                const importBtn = document.getElementById('importAnnotations');
                if (exportBtn) {
                    exportBtn.style.display = enabled ? 'inline-flex' : 'none';
                }
                if (importBtn) {
                    importBtn.style.display = enabled ? 'inline-flex' : 'none';
                }
            }

            buildRecordIndex() {
                this.recordIndexById = new Map();
                this.originalData.forEach((item, idx) => {
                    const recordId = this.getRecordId(item);
                    if (recordId) {
                        this.recordIndexById.set(recordId, idx);
                    } else {
                        console.warn('Missing recordId for item at index', idx);
                    }
                });
            }

            ensureStatusFacet() {
                const statusFacetDisabled = this.schema.curation && this.schema.curation.statusFacet === false;
                if (statusFacetDisabled) {
                    return;
                }
                const statusField = '__curation_status';
                const statusLabel = (this.schema.curation && this.schema.curation.statusFacetLabel) || 'Evaluation Status';
                const hasStatusFacet = this.schema.facets.some(facet => facet.field === statusField);
                if (!hasStatusFacet) {
                    this.schema.facets.unshift({
                        field: statusField,
                        label: statusLabel,
                        type: 'string',
                        sortBy: 'alphabetical'
                    });
                }
            }

            getRecordId(item) {
                if (!this.recordIdField) return null;
                const value = item[this.recordIdField];
                if (value === undefined || value === null) return null;
                return String(value);
            }

            computeDatasetHash() {
                const base = `${this.schema.title || ''}|${this.recordIdField || ''}|${this.originalData.length}`;
                let hash = 2166136261;
                hash = this.hashString(hash, base);
                this.originalData.forEach(item => {
                    const recordId = this.getRecordId(item);
                    if (recordId) {
                        hash = this.hashString(hash, recordId);
                    }
                });
                return `fnv1a:${(hash >>> 0).toString(16)}`;
            }

            hashString(hash, value) {
                let h = hash;
                for (let i = 0; i < value.length; i++) {
                    h ^= value.charCodeAt(i);
                    h = (h >>> 0) * 16777619;
                }
                return h >>> 0;
            }

            getStorageKey() {
                return `linkml_browser_annotations::${this.datasetHash || 'default'}`;
            }

            loadAnnotationsFromStorage() {
                const stored = localStorage.getItem(this.getStorageKey());
                if (!stored) return {};
                try {
                    const parsed = JSON.parse(stored);
                    const annotations = parsed.annotations || parsed;
                    if (Array.isArray(annotations)) {
                        const result = {};
                        annotations.forEach(entry => {
                            if (!entry || !entry.recordId) return;
                            const normalized = this.normalizeAnnotation(entry);
                            result[normalized.recordId] = normalized;
                        });
                        return result;
                    }
                    if (annotations && typeof annotations === 'object') {
                        const result = {};
                        Object.values(annotations).forEach(entry => {
                            if (!entry || !entry.recordId) return;
                            const normalized = this.normalizeAnnotation(entry);
                            result[normalized.recordId] = normalized;
                        });
                        return result;
                    }
                } catch (error) {
                    console.warn('Failed to parse stored annotations', error);
                }
                return {};
            }

            saveAnnotationsToStorage() {
                const payload = {
                    schemaVersion: 1,
                    datasetHash: this.datasetHash,
                    updatedAt: new Date().toISOString(),
                    annotations: this.annotations
                };
                localStorage.setItem(this.getStorageKey(), JSON.stringify(payload));
            }

            normalizeAnnotation(entry) {
                const recordId = String(entry.recordId);
                const data = entry.data && typeof entry.data === 'object' ? entry.data : {};
                const status = this.allowedStatuses.includes(entry.status) ? entry.status : this.computeStatusFromData(data);
                return {
                    recordId,
                    curatorId: entry.curatorId || this.curatorId || null,
                    updatedAt: entry.updatedAt || new Date().toISOString(),
                    status,
                    data
                };
            }

            computeStatusFromData(data) {
                if (!data) return 'pending';
                const hasValues = Object.values(data).some(value => {
                    if (Array.isArray(value)) return value.length > 0;
                    return value !== null && value !== undefined && value !== '';
                });
                return hasValues ? 'draft' : 'pending';
            }

            ensureCuratorId() {
                if (this.curatorId) return this.curatorId;
                const stored = localStorage.getItem('linkml_browser_curator_id');
                if (stored) {
                    this.curatorId = stored;
                    return stored;
                }
                const promptValue = window.prompt('Enter curator ID (optional):');
                if (promptValue && promptValue.trim()) {
                    const trimmed = promptValue.trim();
                    localStorage.setItem('linkml_browser_curator_id', trimmed);
                    this.curatorId = trimmed;
                    return trimmed;
                }
                this.curatorId = 'local';
                return this.curatorId;
            }

            getAnnotation(recordId) {
                return this.annotations[recordId] || null;
            }

            ensureAnnotation(recordId) {
                const key = String(recordId);
                let annotation = this.annotations[key];
                if (!annotation) {
                    annotation = {
                        recordId: key,
                        curatorId: this.ensureCuratorId(),
                        updatedAt: new Date().toISOString(),
                        status: 'draft',
                        data: {}
                    };
                    this.annotations[key] = annotation;
                }
                if (!annotation.data || typeof annotation.data !== 'object') {
                    annotation.data = {};
                }
                if (!annotation.curatorId) {
                    annotation.curatorId = this.ensureCuratorId();
                }
                return annotation;
            }

            getCurationStatus(recordId) {
                const annotation = this.annotations[recordId];
                if (!annotation) return 'pending';
                if (annotation.status && this.allowedStatuses.includes(annotation.status)) {
                    return annotation.status;
                }
                return this.computeStatusFromData(annotation.data);
            }

            getCurationStatusForItem(item) {
                const recordId = this.getRecordId(item);
                if (!recordId) return 'pending';
                return this.getCurationStatus(recordId);
            }

            getRecordById(recordId) {
                const idx = this.recordIndexById.get(recordId);
                if (idx === undefined) return null;
                return this.originalData[idx] || null;
            }

            updateStatusFacetIndex(recordId, oldStatus, newStatus) {
                if (!this.facetIndex || !this.facetIndex['__curation_status']) return;
                const idx = this.recordIndexById.get(recordId);
                if (idx === undefined) return;
                if (oldStatus && this.facetIndex['__curation_status'].has(oldStatus)) {
                    this.facetIndex['__curation_status'].get(oldStatus).delete(idx);
                }
                if (!this.facetIndex['__curation_status'].has(newStatus)) {
                    this.facetIndex['__curation_status'].set(newStatus, new Set());
                }
                this.facetIndex['__curation_status'].get(newStatus).add(idx);
            }

            async exportAnnotations() {
                if (!this.curationEnabled) return;
                const payload = {
                    schemaVersion: 1,
                    datasetHash: this.datasetHash,
                    exportedAt: new Date().toISOString(),
                    annotations: Object.values(this.annotations).map(entry => {
                        const record = this.getRecordById(entry.recordId);
                        return record ? { ...entry, record } : entry;
                    })
                };
                const json = JSON.stringify(payload, null, 2);
                const filename = `annotations_${this.datasetHash || 'export'}.json`;

                if (window.__TAURI__ && window.__TAURI__.dialog && window.__TAURI__.fs) {
                    try {
                        const { save } = window.__TAURI__.dialog;
                        const { writeTextFile } = window.__TAURI__.fs;
                        if (save && writeTextFile) {
                            const path = await save({
                                defaultPath: filename,
                                filters: [{ name: 'JSON', extensions: ['json'] }]
                            });
                            if (path) {
                                await writeTextFile(path, json);
                                return;
                            }
                        }
                    } catch (error) {
                        console.warn('Tauri export failed, falling back to browser download', error);
                    }
                }

                this.downloadBlob(json, filename);
            }

            downloadBlob(contents, filename) {
                const blob = new Blob([contents], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }

            async openDatasetDialog() {
                if (!window.__TAURI__ || !window.__TAURI__.dialog) {
                    return;
                }
                try {
                    const { open } = window.__TAURI__.dialog;
                    const selected = await open({ directory: true, multiple: false });
                    if (!selected) return;
                    localStorage.setItem('linkml_browser_dataset_path', selected);
                    window.location.reload();
                } catch (error) {
                    console.error('Failed to open dataset folder', error);
                    alert('Failed to open dataset folder.');
                }
            }

            async handleImportFile(event) {
                if (!this.curationEnabled) return;
                const file = event.target.files[0];
                if (!file) return;
                try {
                    const text = await file.text();
                    const parsed = JSON.parse(text);
                    const annotations = parsed.annotations || parsed;
                    const entries = Array.isArray(annotations) ? annotations : Object.values(annotations || {});
                    entries.forEach(entry => {
                        if (!entry || !entry.recordId) return;
                        const normalized = this.normalizeAnnotation(entry);
                        this.annotations[normalized.recordId] = normalized;
                    });
                    this.saveAnnotationsToStorage();
                    this.facetIndex = this.buildFacetIndex();
                    this.search();
                } catch (error) {
                    console.error('Failed to import annotations', error);
                    alert('Failed to import annotations. Please check the file format.');
                } finally {
                    event.target.value = '';
                }
            }

            setAnnotationStatus(recordId, status) {
                if (!this.curationEnabled || !this.allowedStatuses.includes(status)) return;
                const annotation = this.ensureAnnotation(recordId);
                const previousStatus = this.getCurationStatus(recordId);
                annotation.status = status;
                annotation.updatedAt = new Date().toISOString();
                this.annotations[recordId] = annotation;
                this.saveAnnotationsToStorage();
                this.updateStatusFacetIndex(recordId, previousStatus, status);
                this.search();
            }

            updateAnnotationField(recordId, field, value) {
                if (!this.curationEnabled) return;
                const annotation = this.ensureAnnotation(recordId);
                const previousStatus = this.getCurationStatus(recordId);
                if (value === null || value === undefined || value === '' || (Array.isArray(value) && value.length === 0)) {
                    delete annotation.data[field];
                } else {
                    annotation.data[field] = value;
                }
                annotation.updatedAt = new Date().toISOString();
                annotation.status = this.computeStatusFromData(annotation.data);
                this.annotations[recordId] = annotation;
                this.saveAnnotationsToStorage();
                this.updateStatusFacetIndex(recordId, previousStatus, annotation.status);
                this.search();
            }

            getAnnotationValue(recordId, field) {
                const annotation = this.annotations[recordId];
                if (!annotation || !annotation.data) return null;
                return annotation.data[field];
            }

            getFacetValue(item, facetConfig) {
                if (facetConfig.field === '__curation_status') {
                    return this.getCurationStatusForItem(item);
                }
                return item[facetConfig.field];
            }

            handleCurationAction(action, recordId) {
                if (!recordId) return;
                if (action === 'submit') {
                    this.setAnnotationStatus(recordId, 'submitted');
                } else if (action === 'discard') {
                    this.setAnnotationStatus(recordId, 'discarded');
                } else if (action === 'edit' || action === 'resume') {
                    this.setAnnotationStatus(recordId, 'draft');
                }
            }

            handleCurationInputChange(target) {
                const recordId = target.dataset.recordId;
                const field = target.dataset.field;
                const type = target.dataset.type;
                if (!recordId || !field || !type) return;

                let value = null;
                if (type === 'text' || type === 'textarea') {
                    const raw = target.value.trim();
                    value = raw === '' ? null : raw;
                } else if (type === 'integer') {
                    const num = parseInt(target.value, 10);
                    value = Number.isNaN(num) ? null : num;
                } else if (type === 'enum') {
                    value = target.value || null;
                } else if (type === 'boolean') {
                    if (target.value === '') {
                        value = null;
                    } else {
                        value = target.value === 'true';
                    }
                } else if (type === 'multienum') {
                    value = this.getMultiSelectValues(recordId, field);
                }

                this.updateAnnotationField(recordId, field, value);
            }

            getMultiSelectValues(recordId, field) {
                const safeId = CSS.escape(recordId);
                const safeField = CSS.escape(field);
                const checkboxes = document.querySelectorAll(`input.curation-multienum[data-record-id="${safeId}"][data-field="${safeField}"]`);
                return Array.from(checkboxes)
                    .filter(box => box.checked)
                    .map(box => box.value);
            }

            renderCurationPanel(recordId) {
                if (!this.curationEnabled || this.curationFields.length === 0) {
                    return '';
                }
                const status = this.getCurationStatus(recordId);
                const sections = this.schema.curation && Array.isArray(this.schema.curation.sections)
                    ? this.schema.curation.sections
                    : null;

                let fieldsHtml = '';
                if (sections) {
                    fieldsHtml = sections.map(section => {
                        const sectionFields = (section.fields || [])
                            .map(fieldName => this.curationFields.find(cfg => cfg.field === fieldName))
                            .filter(Boolean)
                            .map(cfg => this.renderCurationField(recordId, cfg))
                            .join('');
                        if (!sectionFields) return '';
                        return `
                            <div class="curation-section">
                                <div class="curation-label">${section.label || 'Section'}</div>
                                ${sectionFields}
                            </div>
                        `;
                    }).join('');
                } else {
                    fieldsHtml = this.curationFields.map(cfg => this.renderCurationField(recordId, cfg)).join('');
                }

                if (!fieldsHtml) return '';

                let primaryAction = { label: 'Submit', action: 'submit' };
                let secondaryAction = { label: 'Discard', action: 'discard' };

                if (status === 'submitted') {
                    primaryAction = { label: 'Edit', action: 'edit' };
                }
                if (status === 'discarded') {
                    secondaryAction = { label: 'Resume', action: 'resume' };
                }

                return `
                    <div class="curation-panel">
                        <div class="curation-header">Curation</div>
                        ${fieldsHtml}
                        <div class="curation-actions">
                            <span class="curation-status ${status}">${status}</span>
                            <button class="curation-action-btn curation-action" data-action="${primaryAction.action}" data-record-id="${recordId}">
                                ${primaryAction.label}
                            </button>
                            <button class="curation-action-btn secondary curation-action" data-action="${secondaryAction.action}" data-record-id="${recordId}">
                                ${secondaryAction.label}
                            </button>
                        </div>
                    </div>
                `;
            }

            renderCurationField(recordId, fieldConfig) {
                const field = fieldConfig.field;
                const label = fieldConfig.label || field;
                const value = this.getAnnotationValue(recordId, field);
                const type = fieldConfig.type || 'text';

                if (type === 'textarea') {
                    return `
                        <div class="curation-field">
                            <label class="curation-label">${label}</label>
                            <textarea class="curation-textarea curation-input"
                                      data-record-id="${recordId}"
                                      data-field="${field}"
                                      data-type="textarea">${value || ''}</textarea>
                        </div>
                    `;
                }

                if (type === 'text') {
                    return `
                        <div class="curation-field">
                            <label class="curation-label">${label}</label>
                            <input class="curation-input"
                                   type="text"
                                   data-record-id="${recordId}"
                                   data-field="${field}"
                                   data-type="text"
                                   value="${value || ''}">
                        </div>
                    `;
                }

                if (type === 'integer') {
                    const min = fieldConfig.min !== undefined ? `min="${fieldConfig.min}"` : '';
                    const max = fieldConfig.max !== undefined ? `max="${fieldConfig.max}"` : '';
                    const current = value !== null && value !== undefined ? value : '';
                    return `
                        <div class="curation-field">
                            <label class="curation-label">${label}</label>
                            <input class="curation-input"
                                   type="number"
                                   ${min}
                                   ${max}
                                   data-record-id="${recordId}"
                                   data-field="${field}"
                                   data-type="integer"
                                   value="${current}">
                        </div>
                    `;
                }

                if (type === 'boolean') {
                    const selected = value === true ? 'true' : value === false ? 'false' : '';
                    return `
                        <div class="curation-field">
                            <label class="curation-label">${label}</label>
                            <select class="curation-select"
                                    data-record-id="${recordId}"
                                    data-field="${field}"
                                    data-type="boolean">
                                <option value="" ${selected === '' ? 'selected' : ''}>‚Äî</option>
                                <option value="true" ${selected === 'true' ? 'selected' : ''}>Yes</option>
                                <option value="false" ${selected === 'false' ? 'selected' : ''}>No</option>
                            </select>
                        </div>
                    `;
                }

                if (type === 'enum') {
                    const options = (fieldConfig.choices || []).map(choice => {
                        const selected = value === choice ? 'selected' : '';
                        return `<option value="${choice}" ${selected}>${choice}</option>`;
                    }).join('');
                    return `
                        <div class="curation-field">
                            <label class="curation-label">${label}</label>
                            <select class="curation-select"
                                    data-record-id="${recordId}"
                                    data-field="${field}"
                                    data-type="enum">
                                <option value="">‚Äî</option>
                                ${options}
                            </select>
                        </div>
                    `;
                }

                if (type === 'multienum') {
                    const selectedValues = Array.isArray(value) ? value : [];
                    const options = (fieldConfig.choices || []).map(choice => {
                        const checked = selectedValues.includes(choice) ? 'checked' : '';
                        return `
                            <label class="curation-checkbox">
                                <input type="checkbox"
                                       class="curation-multienum"
                                       data-record-id="${recordId}"
                                       data-field="${field}"
                                       data-type="multienum"
                                       value="${choice}"
                                       ${checked}>
                                ${choice}
                            </label>
                        `;
                    }).join('');
                    return `
                        <div class="curation-field">
                            <label class="curation-label">${label}</label>
                            <div class="curation-multiselect">${options}</div>
                        </div>
                    `;
                }

                if (type === 'rating') {
                    return `
                        <div class="curation-field">
                            <label class="curation-label">${label}</label>
                            ${this.renderRating(recordId, field, value, fieldConfig.min || 1, fieldConfig.max || 5)}
                        </div>
                    `;
                }

                return `
                    <div class="curation-field">
                        <label class="curation-label">${label}</label>
                        <input class="curation-input"
                               type="text"
                               data-record-id="${recordId}"
                               data-field="${field}"
                               data-type="text"
                               value="${value || ''}">
                    </div>
                `;
            }

            renderDecorators(recordId, decorators) {
                if (!this.curationEnabled || !decorators || decorators.length === 0) return '';
                const html = decorators.map(decorator => {
                    if (decorator.type === 'thumbs') {
                        return this.renderThumbs(recordId, decorator.field);
                    }
                    if (decorator.type === 'rating') {
                        return this.renderRating(recordId, decorator.field, this.getAnnotationValue(recordId, decorator.field), decorator.min || 1, decorator.max || 5);
                    }
                    return '';
                }).join('');

                if (!html) return '';
                return `<div class="curation-decorators">${html}</div>`;
            }

            renderThumbs(recordId, field) {
                const value = this.getAnnotationValue(recordId, field);
                const upActive = value === true ? 'active' : '';
                const downActive = value === false ? 'active' : '';
                return `
                    <button class="curation-thumb ${upActive}" data-record-id="${recordId}" data-field="${field}" data-value="true">üëç</button>
                    <button class="curation-thumb ${downActive}" data-record-id="${recordId}" data-field="${field}" data-value="false">üëé</button>
                `;
            }

            renderRating(recordId, field, currentValue, min, max) {
                const current = parseInt(currentValue, 10) || 0;
                const stars = [];
                for (let i = min; i <= max; i++) {
                    const active = i <= current ? 'active' : '';
                    stars.push(`
                        <button class="curation-rating-star ${active}"
                                data-record-id="${recordId}"
                                data-field="${field}"
                                data-value="${i}">
                            ‚òÖ
                        </button>
                    `);
                }
                return `<div class="curation-rating">${stars.join('')}</div>`;
            }
            
            // Build inverted index for fast text search
            buildSearchIndex() {
                console.log('Building search index for', this.originalData.length, 'items');
                const index = new Map();
                
                this.originalData.forEach((item, idx) => {
                    // Get all searchable text
                    const searchText = this.schema.searchableFields
                        .map(field => {
                            const value = item[field];
                            if (value === undefined || value === null) {
                                console.warn(`Missing field ${field} in item:`, item);
                                return '';
                            }
                            if (Array.isArray(value)) {
                                return value.join(' ');
                            }
                            return String(value);
                        })
                        .join(' ')
                        .toLowerCase();
                    
                    // Tokenize and index
                    const tokens = searchText.split(/\s+/).filter(token => token.length > 0);
                    tokens.forEach(token => {
                        if (!index.has(token)) {
                            index.set(token, new Set());
                        }
                        index.get(token).add(idx);
                    });
                });
                
                console.log('Search index created with', index.size, 'unique tokens');
                return index;
            }
            
            // Build facet index for fast filtering
            buildFacetIndex() {
                console.log('Building facet index for fields:', this.schema.facets.map(f => f.field));
                const index = {};
                
                this.schema.facets.forEach(facet => {
                    index[facet.field] = new Map();
                    console.log(`Processing facet: ${facet.field} (type: ${facet.type})`);
                    
                    this.originalData.forEach((item, idx) => {
                        const value = this.getFacetValue(item, facet);
                        
                        if (value === undefined || value === null) {
                            console.warn(`Missing facet field ${facet.field} in item ${idx}:`, item);
                            return;
                        }
                        
                        if (facet.type === 'array') {
                            if (!Array.isArray(value)) {
                                console.warn(`Expected array for ${facet.field} in item ${idx}, got:`, typeof value, value);
                                // Try to convert single values to arrays
                                const arrayValue = [value];
                                arrayValue.forEach(val => {
                                    if (val !== undefined && val !== null) {
                                        const key = String(val);
                                        if (!index[facet.field].has(key)) {
                                            index[facet.field].set(key, new Set());
                                        }
                                        index[facet.field].get(key).add(idx);
                                    }
                                });
                                return;
                            }
                            
                            // Handle array case with safety check
                            value.forEach(val => {
                                if (val !== undefined && val !== null) {
                                    const key = String(val);
                                    if (!index[facet.field].has(key)) {
                                        index[facet.field].set(key, new Set());
                                    }
                                    index[facet.field].get(key).add(idx);
                                }
                            });
                        } else {
                            const key = String(value);
                            if (!index[facet.field].has(key)) {
                                index[facet.field].set(key, new Set());
                            }
                            index[facet.field].get(key).add(idx);
                        }
                    });
                    
                    console.log(`Facet ${facet.field} indexed with`, index[facet.field].size, 'unique values');
                });
                
                return index;
            }
            
            setupEventListeners() {
                let searchTimeout;
                document.getElementById('searchBox').addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        this.currentQuery = e.target.value;
                        this.search();
                    }, 150); // Debounce for better UX
                });
                
                document.addEventListener('click', (e) => {
                    if (e.target.closest('.facet-item')) {
                        this.handleFacetClick(e.target.closest('.facet-item'));
                    } else if (e.target.closest('.facet-header')) {
                        this.handleFacetToggle(e.target.closest('.facet-header'));
                    }
                });

                document.getElementById('clearFilters').addEventListener('click', () => {
                    this.clearAllFilters();
                });

                // Range slider event handlers
                this.setupRangeSliderEvents();

                // Load more button (delegated since it's dynamically created)
                document.addEventListener('click', (e) => {
                    if (e.target.id === 'loadMoreBtn') {
                        this.loadMore();
                    }
                    // Facet show more button
                    if (e.target.classList.contains('facet-show-more')) {
                        const field = e.target.dataset.field;
                        if (this.expandedFacets.has(field)) {
                            this.expandedFacets.delete(field);
                        } else {
                            this.expandedFacets.add(field);
                        }
                        // Re-render facets with cached counts
                        if (this.currentFacetCounts) {
                            this.renderFacets(this.currentFacetCounts);
                        }
                    }
                    // Range slider clear button
                    if (e.target.classList.contains('range-slider-clear')) {
                        const field = e.target.dataset.field;
                        delete this.currentFilters[field];
                        this.search();
                    }
                });

                const exportBtn = document.getElementById('exportAnnotations');
                const importBtn = document.getElementById('importAnnotations');
                const importFile = document.getElementById('importAnnotationsFile');
                if (exportBtn) {
                    exportBtn.addEventListener('click', () => this.exportAnnotations());
                }
                if (importBtn && importFile) {
                    importBtn.addEventListener('click', () => importFile.click());
                    importFile.addEventListener('change', (event) => this.handleImportFile(event));
                }

                const openDatasetBtn = document.getElementById('openDataset');
                if (openDatasetBtn) {
                    if (window.__TAURI__ && window.__TAURI__.dialog) {
                        openDatasetBtn.addEventListener('click', () => this.openDatasetDialog());
                    } else {
                        openDatasetBtn.style.display = 'none';
                    }
                }

                document.addEventListener('click', (e) => {
                    const actionBtn = e.target.closest('.curation-action');
                    if (actionBtn) {
                        const recordId = actionBtn.dataset.recordId;
                        const action = actionBtn.dataset.action;
                        this.handleCurationAction(action, recordId);
                        return;
                    }

                    const thumbBtn = e.target.closest('.curation-thumb');
                    if (thumbBtn) {
                        const recordId = thumbBtn.dataset.recordId;
                        const field = thumbBtn.dataset.field;
                        const value = thumbBtn.dataset.value === 'true';
                        const current = this.getAnnotationValue(recordId, field);
                        const nextValue = current === value ? null : value;
                        this.updateAnnotationField(recordId, field, nextValue);
                        return;
                    }

                    const ratingBtn = e.target.closest('.curation-rating-star');
                    if (ratingBtn) {
                        const recordId = ratingBtn.dataset.recordId;
                        const field = ratingBtn.dataset.field;
                        const value = parseInt(ratingBtn.dataset.value, 10);
                        const current = this.getAnnotationValue(recordId, field);
                        const nextValue = current === value ? null : value;
                        this.updateAnnotationField(recordId, field, nextValue);
                    }
                });

                document.addEventListener('change', (e) => {
                    if (e.target.classList.contains('curation-input') ||
                        e.target.classList.contains('curation-select') ||
                        e.target.classList.contains('curation-multienum')) {
                        this.handleCurationInputChange(e.target);
                    }
                });
            }

            setupRangeSliderEvents() {
                let activeHandle = null;
                let activeWrapper = null;

                const getValueFromPosition = (wrapper, clientX) => {
                    const rect = wrapper.getBoundingClientRect();
                    const min = parseInt(wrapper.dataset.min);
                    const max = parseInt(wrapper.dataset.max);
                    const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                    return Math.round(min + percent * (max - min));
                };

                const updateSliderVisual = (wrapper, minVal, maxVal) => {
                    const min = parseInt(wrapper.dataset.min);
                    const max = parseInt(wrapper.dataset.max);
                    const range = max - min;
                    const minPercent = range > 0 ? ((minVal - min) / range) * 100 : 0;
                    const maxPercent = range > 0 ? ((maxVal - min) / range) * 100 : 100;

                    const rangeEl = wrapper.querySelector('.range-slider-range');
                    const minHandle = wrapper.querySelector('.range-slider-handle-min');
                    const maxHandle = wrapper.querySelector('.range-slider-handle-max');
                    const minLabel = wrapper.parentElement.querySelector('.range-slider-label-min');
                    const maxLabel = wrapper.parentElement.querySelector('.range-slider-label-max');

                    rangeEl.style.left = minPercent + '%';
                    rangeEl.style.right = (100 - maxPercent) + '%';
                    minHandle.style.left = minPercent + '%';
                    maxHandle.style.left = maxPercent + '%';
                    minLabel.textContent = minVal;
                    maxLabel.textContent = maxVal;
                };

                const handleMove = (clientX) => {
                    if (!activeHandle || !activeWrapper) return;

                    const field = activeWrapper.dataset.field;
                    const min = parseInt(activeWrapper.dataset.min);
                    const max = parseInt(activeWrapper.dataset.max);
                    const handleType = activeHandle.dataset.type;
                    const newValue = getValueFromPosition(activeWrapper, clientX);

                    if (!this.currentFilters[field]) {
                        this.currentFilters[field] = { min, max };
                    }

                    if (handleType === 'min') {
                        this.currentFilters[field].min = Math.min(newValue, this.currentFilters[field].max);
                    } else {
                        this.currentFilters[field].max = Math.max(newValue, this.currentFilters[field].min);
                    }

                    updateSliderVisual(activeWrapper, this.currentFilters[field].min, this.currentFilters[field].max);
                };

                const handleEnd = () => {
                    if (activeHandle && activeWrapper) {
                        const field = activeWrapper.dataset.field;
                        const min = parseInt(activeWrapper.dataset.min);
                        const max = parseInt(activeWrapper.dataset.max);

                        // If range is back to full, clear the filter
                        if (this.currentFilters[field] &&
                            this.currentFilters[field].min === min &&
                            this.currentFilters[field].max === max) {
                            delete this.currentFilters[field];
                        }

                        this.search();
                    }
                    activeHandle = null;
                    activeWrapper = null;
                };

                // Mouse events
                document.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('range-slider-handle')) {
                        activeHandle = e.target;
                        activeWrapper = e.target.closest('.range-slider-wrapper');
                        e.preventDefault();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (activeHandle) {
                        handleMove(e.clientX);
                    }
                });

                document.addEventListener('mouseup', handleEnd);

                // Touch events for mobile
                document.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('range-slider-handle')) {
                        activeHandle = e.target;
                        activeWrapper = e.target.closest('.range-slider-wrapper');
                    }
                }, { passive: true });

                document.addEventListener('touchmove', (e) => {
                    if (activeHandle && e.touches.length > 0) {
                        handleMove(e.touches[0].clientX);
                    }
                }, { passive: true });

                document.addEventListener('touchend', handleEnd);
            }
            
            handleFacetClick(facetItem) {
                const filterKey = facetItem.dataset.filter;
                const value = facetItem.dataset.value;
                
                if (!this.currentFilters[filterKey]) {
                    this.currentFilters[filterKey] = [];
                }
                
                const index = this.currentFilters[filterKey].indexOf(value);
                if (index > -1) {
                    this.currentFilters[filterKey].splice(index, 1);
                    if (this.currentFilters[filterKey].length === 0) {
                        delete this.currentFilters[filterKey];
                    }
                } else {
                    this.currentFilters[filterKey].push(value);
                }
                
                this.search();
            }
            
            handleFacetToggle(facetHeader) {
                const field = facetHeader.dataset.field;
                const facetContent = facetHeader.nextElementSibling;
                const toggle = facetHeader.querySelector('.facet-toggle');
                
                if (this.collapsedFacets.has(field)) {
                    // Expand
                    this.collapsedFacets.delete(field);
                    facetContent.classList.remove('collapsed');
                    toggle.classList.remove('collapsed');
                } else {
                    // Collapse
                    this.collapsedFacets.add(field);
                    facetContent.classList.add('collapsed');
                    toggle.classList.add('collapsed');
                }
            }
            
            clearAllFilters() {
                this.currentFilters = {};
                this.currentQuery = '';
                document.getElementById('searchBox').value = '';
                this.search();
            }

            search() {
                const startTime = performance.now();
                
                let resultIndices = new Set();
                
                // Apply text search using inverted index
                if (this.currentQuery.trim()) {
                    const tokens = this.currentQuery.toLowerCase().split(/\s+/);
                    
                    if (tokens.length > 0) {
                        // Start with results for first token
                        const firstToken = tokens[0];
                        const matchingIndices = new Set();
                        
                        // Find partial matches for better UX
                        for (const [indexToken, indices] of this.searchIndex) {
                            if (indexToken.includes(firstToken)) {
                                indices.forEach(idx => matchingIndices.add(idx));
                            }
                        }
                        
                        resultIndices = matchingIndices;
                        
                        // Intersect with other tokens
                        for (let i = 1; i < tokens.length; i++) {
                            const token = tokens[i];
                            const tokenMatches = new Set();
                            
                            for (const [indexToken, indices] of this.searchIndex) {
                                if (indexToken.includes(token)) {
                                    indices.forEach(idx => tokenMatches.add(idx));
                                }
                            }
                            
                            // Intersect
                            resultIndices = new Set([...resultIndices].filter(idx => tokenMatches.has(idx)));
                        }
                    }
                } else {
                    // No search query, include all items
                    resultIndices = new Set(Array.from({length: this.originalData.length}, (_, i) => i));
                }
                
                // Apply facet filters using pre-computed index
                for (const [filterKey, filterValues] of Object.entries(this.currentFilters)) {
                    const facetConfig = this.schema.facets.find(f => f.field === filterKey);
                    
                    if (facetConfig && facetConfig.type === 'integer') {
                        // Handle numeric range filters
                        const range = filterValues;
                        console.log(`Applying range filter for ${filterKey}:`, range);
                        
                        resultIndices = new Set([...resultIndices].filter(idx => {
                            const item = this.originalData[idx];
                            const value = parseInt(item[filterKey]);
                            return !isNaN(value) && value >= range.min && value <= range.max;
                        }));
                    } else if (filterValues.length > 0) {
                        if (facetConfig && facetConfig.type === 'array') {
                            // For array fields, use AND logic: item must have ALL selected values
                            console.log(`Applying AND logic for array field ${filterKey}:`, filterValues);
                            
                            resultIndices = new Set([...resultIndices].filter(idx => {
                                const item = this.originalData[idx];
                                const itemValues = item[filterKey] || [];
                                
                                // Check if item has ALL selected filter values
                                return filterValues.every(selectedValue => 
                                    itemValues.includes(selectedValue)
                                );
                            }));
                        } else {
                            // For scalar fields, use OR logic: item must match ANY selected value
                            console.log(`Applying OR logic for scalar field ${filterKey}:`, filterValues);
                            
                            const facetMatches = new Set();
                            
                            filterValues.forEach(value => {
                                const indices = this.facetIndex[filterKey].get(value);
                                if (indices) {
                                    indices.forEach(idx => facetMatches.add(idx));
                                }
                            });
                            
                            // Intersect with current results
                            resultIndices = new Set([...resultIndices].filter(idx => facetMatches.has(idx)));
                        }
                    }
                }
                
                // Get actual data objects
                const filteredData = Array.from(resultIndices).map(idx => this.originalData[idx]);

                // Store for pagination and reset displayed count on new search
                this.currentFilteredData = filteredData;
                this.displayedCount = this.itemsPerPage;

                // Generate facet counts for current result set and cache them
                this.currentFacetCounts = this.generateFacetCounts(resultIndices);
                const facetCounts = this.currentFacetCounts;

                const endTime = performance.now();
                document.getElementById('performanceInfo').textContent =
                    `Search: ${(endTime - startTime).toFixed(2)}ms`;

                this.renderResults();
                this.renderFacets(facetCounts);
            }

            loadMore() {
                this.displayedCount += this.itemsPerPage;
                this.renderResults();
            }
            
            generateFacetCounts(resultIndices) {
                const counts = {};
                
                this.schema.facets.forEach(facet => {
                    counts[facet.field] = new Map();
                    
                    resultIndices.forEach(idx => {
                        const item = this.originalData[idx];
                        const value = this.getFacetValue(item, facet);
                        
                        // Skip if value is missing
                        if (value === undefined || value === null) {
                            return;
                        }
                        
                        if (facet.type === 'array') {
                            // Handle case where array field might not be an array
                            if (Array.isArray(value)) {
                                value.forEach(val => {
                                    if (val !== undefined && val !== null) {
                                        const key = String(val);
                                        counts[facet.field].set(key, (counts[facet.field].get(key) || 0) + 1);
                                    }
                                });
                            } else {
                                // Treat single value as array of one
                                const key = String(value);
                                counts[facet.field].set(key, (counts[facet.field].get(key) || 0) + 1);
                            }
                        } else {
                            const key = String(value);
                            counts[facet.field].set(key, (counts[facet.field].get(key) || 0) + 1);
                        }
                    });
                });
                
                return counts;
            }
            
            renderResults() {
                const items = this.currentFilteredData;
                const resultsCount = document.getElementById('resultsCount');
                const resultsGrid = document.getElementById('resultsGrid');

                const totalCount = items.length;
                const showingCount = Math.min(this.displayedCount, totalCount);
                resultsCount.textContent = `Showing ${showingCount} of ${totalCount} items`;

                if (totalCount === 0) {
                    resultsGrid.innerHTML = `
                        <div class="no-results">
                            <div style="font-size: 4rem; margin-bottom: 20px;">üîç</div>
                            <h3>No items found</h3>
                            <p>Try adjusting your filters or search terms</p>
                        </div>
                    `;
                    return;
                }

                // Only render up to displayedCount items
                const itemsToRender = items.slice(0, this.displayedCount);

                // Generic rendering based on schema displayFields
                let html = itemsToRender.map(item => {
                    const recordId = this.getRecordId(item);
                    const fieldsHtml = this.schema.displayFields.map(fieldConfig => {
                        const value = item[fieldConfig.field];

                        if (value === undefined || value === null) {
                            return '';
                        }

                        if (fieldConfig.type === 'array') {
                            if (Array.isArray(value)) {
                                return `
                                    <div class="field-display">
                                        <span class="field-label">${fieldConfig.label}:</span>
                                        <div class="array-values">
                                            ${value.map(v => `<span class="array-item">${v}</span>`).join('')}
                                        </div>
                                        ${recordId ? this.renderDecorators(recordId, fieldConfig.decorators) : ''}
                                    </div>
                                `;
                            } else {
                                return `
                                    <div class="field-display">
                                        <span class="field-label">${fieldConfig.label}:</span>
                                        <span class="array-item">${value}</span>
                                        ${recordId ? this.renderDecorators(recordId, fieldConfig.decorators) : ''}
                                    </div>
                                `;
                            }
                        } else {
                            let displayValue = value;
                            if (fieldConfig.format === 'currency') {
                                displayValue = `${value}`;
                            }

                            // Generic handling for CURIE type fields
                            if (fieldConfig.type === 'curie' && value.includes(':')) {
                                // Create hyperlink for any CURIE (Compact URI)
                                const curieUrl = `https://bioregistry.io/${value}`;
                                displayValue = `<a href="${curieUrl}" target="_blank" style="color: #10b981; text-decoration: none; border-bottom: 1px dashed #10b981;">${displayValue}</a>`;
                            }

                            // Generic handling for URL type fields
                            if (fieldConfig.type === 'url' && value) {
                                // Handle local URLs (starting with ../) or full URLs
                                const isLocalUrl = value.startsWith('../');
                                const target = isLocalUrl ? '_blank' : '_blank';  // Open both in new tab
                                displayValue = `<a href="${value}" target="${target}" style="color: #10b981; text-decoration: none; border-bottom: 1px dashed #10b981;">${fieldConfig.label}</a>`;
                            }

                            return `
                                <div class="field-display">
                                    <span class="field-label">${fieldConfig.label}:</span>
                                    <span class="field-value">${displayValue}</span>
                                    ${recordId ? this.renderDecorators(recordId, fieldConfig.decorators) : ''}
                                </div>
                            `;
                        }
                    }).join('');

                    const curationHtml = recordId && this.curationLayout === 'inline'
                        ? this.renderCurationPanel(recordId)
                        : '';
                    return `<div class="result-card" data-record-id="${recordId || ''}">${fieldsHtml}${curationHtml}</div>`;
                }).join('');

                // Add "Load More" button if there are more items
                if (this.displayedCount < totalCount) {
                    const remaining = totalCount - this.displayedCount;
                    html += `
                        <div class="load-more-container">
                            <button class="load-more-btn" id="loadMoreBtn">
                                Load More Results
                            </button>
                            <div class="load-more-info">${remaining.toLocaleString()} more items available</div>
                        </div>
                    `;
                }

                resultsGrid.innerHTML = html;
            }
            
            renderFacets(facetCounts) {
                const sidebar = document.getElementById('facetsSidebar');
                
                const facetsHtml = this.schema.facets.map(facetConfig => {
                    const counts = facetCounts[facetConfig.field] || new Map();
                    
                    if (counts.size === 0) {
                        return '';
                    }
                    
                    // Check if this facet is collapsed
                    const isCollapsed = this.collapsedFacets.has(facetConfig.field);
                    
                    // Handle integer type facets with range slider
                    if (facetConfig.type === 'integer') {
                        // Get min and max from ORIGINAL data (facetIndex), not filtered counts
                        const originalValues = this.facetIndex[facetConfig.field];
                        if (!originalValues || originalValues.size === 0) return '';

                        const allValues = Array.from(originalValues.keys()).map(k => parseInt(k)).filter(v => !isNaN(v));
                        if (allValues.length === 0) return '';

                        const minValue = Math.min(...allValues);
                        const maxValue = Math.max(...allValues);

                        // Get current filter range (defaults to full range)
                        const currentRange = this.currentFilters[facetConfig.field] || { min: minValue, max: maxValue };
                        const hasActiveFilter = this.currentFilters[facetConfig.field] !== undefined;

                        // Calculate handle positions as percentages
                        const range = maxValue - minValue;
                        const minPercent = range > 0 ? ((currentRange.min - minValue) / range) * 100 : 0;
                        const maxPercent = range > 0 ? ((currentRange.max - minValue) / range) * 100 : 100;

                        return `
                            <div class="facet-group">
                                <div class="facet-header" data-field="${facetConfig.field}">
                                    <div class="facet-title">${facetConfig.label}</div>
                                    <div class="facet-toggle ${isCollapsed ? 'collapsed' : ''}">‚ñº</div>
                                </div>
                                <div class="facet-content ${isCollapsed ? 'collapsed' : ''}">
                                    <div class="numeric-filter-container" style="position: relative;">
                                        ${hasActiveFilter ? `<button class="range-slider-clear" data-field="${facetConfig.field}">Clear</button>` : ''}
                                        <div class="range-slider-wrapper"
                                             data-field="${facetConfig.field}"
                                             data-min="${minValue}"
                                             data-max="${maxValue}">
                                            <div class="range-slider-track"></div>
                                            <div class="range-slider-range" style="left: ${minPercent}%; right: ${100 - maxPercent}%;"></div>
                                            <div class="range-slider-handle range-slider-handle-min"
                                                 data-type="min"
                                                 style="left: ${minPercent}%;"></div>
                                            <div class="range-slider-handle range-slider-handle-max"
                                                 data-type="max"
                                                 style="left: ${maxPercent}%;"></div>
                                        </div>
                                        <div class="range-slider-labels">
                                            <span class="range-slider-label range-slider-label-min">${currentRange.min}</span>
                                            <span class="range-slider-label range-slider-label-max">${currentRange.max}</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Regular facet handling for non-integer types
                    // Convert Map to array and sort
                    const buckets = Array.from(counts.entries())
                        .map(([key, count]) => ({ key, doc_count: count }))
                        .sort((a, b) => {
                            if (facetConfig.sortBy === 'count') {
                                return b.doc_count - a.doc_count;
                            } else {
                                return a.key.localeCompare(b.key);
                            }
                        });

                    // Determine how many facet items to show
                    const isExpanded = this.expandedFacets.has(facetConfig.field);
                    const maxToShow = isExpanded ? buckets.length : this.facetItemsToShow;
                    const bucketsToShow = buckets.slice(0, maxToShow);
                    const hasMore = buckets.length > this.facetItemsToShow;

                    const itemsHtml = bucketsToShow.map(bucket => {
                        const isActive = this.currentFilters[facetConfig.field] &&
                                        this.currentFilters[facetConfig.field].includes(bucket.key);

                        // Create hyperlink for CURIE type facets
                        let displayValue = bucket.key;
                        if (facetConfig.type === 'curie' && bucket.key.includes(':')) {
                            const curieUrl = `https://bioregistry.io/${bucket.key}`;
                            displayValue = `<a href="${curieUrl}" target="_blank" style="color: inherit; text-decoration: none;" onclick="event.stopPropagation();">${bucket.key}</a>`;
                        }

                        return `
                            <div class="facet-item ${isActive ? 'active' : ''}"
                                 data-filter="${facetConfig.field}"
                                 data-value="${bucket.key}">
                                <input type="checkbox" class="facet-checkbox" ${isActive ? 'checked' : ''}>
                                <span>${displayValue}</span>
                                <span class="facet-count">${bucket.doc_count}</span>
                            </div>
                        `;
                    }).join('');

                    // Add show more/less button if needed
                    let showMoreBtn = '';
                    if (hasMore) {
                        const remaining = buckets.length - this.facetItemsToShow;
                        showMoreBtn = `
                            <button class="facet-show-more" data-field="${facetConfig.field}">
                                ${isExpanded ? 'Show Less' : `Show ${remaining} More`}
                            </button>
                        `;
                    }

                    return `
                        <div class="facet-group">
                            <div class="facet-header" data-field="${facetConfig.field}">
                                <div class="facet-title">${facetConfig.label} (${buckets.length})</div>
                                <div class="facet-toggle ${isCollapsed ? 'collapsed' : ''}">‚ñº</div>
                            </div>
                            <div class="facet-content ${isCollapsed ? 'collapsed' : ''}">
                                ${itemsHtml}
                                ${showMoreBtn}
                            </div>
                        </div>
                    `;
                }).join('');
                
                sidebar.innerHTML = facetsHtml;
            }
        }

        // Sample data matching your structure for testing
        const sampleData = [
            {
                "id": "gomodel:56170d5200000012",
                "title": "kctd10 in heart development PMID:24430697",
                "taxon": "NCBITaxon:7955",
                "status": "production",
                "model_activity_part_of_rollup_label": ["anatomical structure development"],
                "number_of_activities": 5
            },
            {
                "id": "gomodel:568b0f9600000284", 
                "title": "Antibacterial innate immune response in the intestine via MAPK cascade (C. elegans)",
                "taxon": "NCBITaxon:6239",
                "status": "production",
                "model_activity_part_of_rollup_label": ["immune system process", "defense response to other organism"],
                "number_of_activities": 12
            },
            {
                "id": "gomodel:test123",
                "title": "Test model for neural development",
                "taxon": "NCBITaxon:10090", 
                "status": "development",
                "model_activity_part_of_rollup_label": ["nervous system development", "cell differentiation"],
                "number_of_activities": 8
            }
        ];

        const sampleSchema = {
            "title": "GO Model Catalog",
            "description": "Search and filter GO models by multiple criteria", 
            "searchPlaceholder": "Search models...",
            "searchableFields": ["title", "model_activity_part_of_rollup_label"],
            "facets": [
                {
                    "field": "taxon",
                    "label": "Taxon", 
                    "type": "string",
                    "sortBy": "count"
                },
                {
                    "field": "status",
                    "label": "Status",
                    "type": "string", 
                    "sortBy": "alphabetical"
                },
                {
                    "field": "model_activity_part_of_rollup_label",
                    "label": "Biological Process",
                    "type": "array",
                    "sortBy": "count"
                }
            ],
            "displayFields": [
                { "field": "title", "label": "Title", "type": "string" },
                { "field": "taxon", "label": "Taxon", "type": "string" },
                { "field": "status", "label": "Status", "type": "string" },
                { "field": "model_activity_part_of_rollup_label", "label": "Biological Process", "type": "array" }
            ]
        };

        function parseJsonArrayFromJs(text) {
            const start = text.indexOf('[');
            const end = text.lastIndexOf(']');
            if (start === -1 || end === -1) {
                throw new Error('Failed to find JSON array in data file.');
            }
            return JSON.parse(text.slice(start, end + 1));
        }

        function parseJsonObjectFromJs(text) {
            const start = text.indexOf('{');
            const end = text.lastIndexOf('}');
            if (start === -1 || end === -1) {
                throw new Error('Failed to find JSON object in schema file.');
            }
            return JSON.parse(text.slice(start, end + 1));
        }

        async function loadDatasetFromPath(datasetPath) {
            const fsApi = window.__TAURI__ && window.__TAURI__.fs;
            if (!fsApi || !fsApi.readTextFile) {
                throw new Error('Tauri filesystem API unavailable.');
            }
            const pathApi = window.__TAURI__.path;
            const join = pathApi && pathApi.join ? pathApi.join : null;
            const dataPath = join ? await join(datasetPath, 'data.js') : `${datasetPath}/data.js`;
            const schemaPath = join ? await join(datasetPath, 'schema.js') : `${datasetPath}/schema.js`;
            const dataText = await fsApi.readTextFile(dataPath);
            const schemaText = await fsApi.readTextFile(schemaPath);
            return {
                data: parseJsonArrayFromJs(dataText),
                schema: parseJsonObjectFromJs(schemaText)
            };
        }

        // Initialize when ready
        function initializeSearch(dataOverride, schemaOverride) {
            console.log('üîç Initializing search...');
            
            const data = dataOverride || window.searchData || sampleData;
            const schema = schemaOverride || window.searchSchema || sampleSchema;
            
            // Set title and description from schema
            if (schema.title) {
                document.getElementById('appTitle').textContent = schema.title;
            }
            if (schema.description) {
                document.getElementById('appDescription').textContent = schema.description;
            }
            
            // Set search placeholder
            if (schema.searchPlaceholder) {
                document.getElementById('searchBox').placeholder = schema.searchPlaceholder;
            }

            // Inject custom CSS if provided
            if (schema.customCss) {
                const styleEl = document.createElement('style');
                styleEl.textContent = schema.customCss;
                document.head.appendChild(styleEl);
            }
            
            console.log('üìä Data check:', {
                dataLoaded: !!window.searchData,
                schemaLoaded: !!window.searchSchema,
                dataLength: data ? data.length : 0,
                dataType: typeof data,
                isArray: Array.isArray(data),
                sampleItem: data && data.length > 0 ? data[0] : null,
                schemaType: typeof schema,
                schema: schema
            });
            
            // Validate data structure
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.error('‚ùå Invalid data:', data);
                document.getElementById('resultsCount').textContent = 'Error: Invalid data format';
                return;
            }
            
            // Validate schema with detailed checks
            if (!schema) {
                console.error('‚ùå Schema is null/undefined');
                document.getElementById('resultsCount').textContent = 'Error: Schema is missing';
                return;
            }
            
            if (!schema.facets) {
                console.error('‚ùå Schema missing facets array:', schema);
                document.getElementById('resultsCount').textContent = 'Error: Schema missing facets';
                return;
            }
            
            if (!Array.isArray(schema.facets)) {
                console.error('‚ùå Schema facets is not an array:', typeof schema.facets, schema.facets);
                document.getElementById('resultsCount').textContent = 'Error: Schema facets must be an array';
                return;
            }
            
            if (!schema.searchableFields) {
                console.error('‚ùå Schema missing searchableFields:', schema);
                document.getElementById('resultsCount').textContent = 'Error: Schema missing searchableFields';
                return;
            }
            
            if (!Array.isArray(schema.searchableFields)) {
                console.error('‚ùå Schema searchableFields is not an array:', typeof schema.searchableFields, schema.searchableFields);
                document.getElementById('resultsCount').textContent = 'Error: Schema searchableFields must be an array';
                return;
            }
            
            // Check if searchable fields exist in data
            const firstItem = data[0];
            console.log('üîç First data item:', firstItem);
            console.log('üè∑Ô∏è Schema searchableFields:', schema.searchableFields);
            console.log('üìä Schema facets:', schema.facets);
            
            const missingFields = schema.searchableFields.filter(field => !(field in firstItem));
            if (missingFields.length > 0) {
                console.warn('‚ö†Ô∏è Missing searchable fields:', missingFields);
            }
            
            // Check if facet fields exist in data
            const missingFacetFields = schema.facets
                .filter(facet => !facet.field.startsWith('__'))
                .filter(facet => !(facet.field in firstItem));
            if (missingFacetFields.length > 0) {
                console.warn('‚ö†Ô∏è Missing facet fields:', missingFacetFields.map(f => f.field));
            }
            
            try {
                console.log('üöÄ Creating search instance...');
                window.searchApp = new OptimizedFacetedSearch(data, schema);
                console.log('‚úÖ Search initialized successfully');
            } catch (error) {
                console.error('‚ùå Error initializing search:', error);
                document.getElementById('resultsCount').textContent = `Error: ${error.message}`;
            }
        }

        // Add more detailed event listening with better timing
        console.log('üîß Setting up event listeners...');
        
        let initializationAttempted = false;

        function setupStandardInitialization() {
            function tryInitialize() {
                if (initializationAttempted) {
                    console.log('‚è≠Ô∏è Initialization already attempted, skipping');
                    return;
                }
                
                if (window.searchData && window.searchSchema) {
                    console.log('‚úÖ Both data and schema available, initializing...');
                    initializationAttempted = true;
                    initializeSearch();
                } else {
                    console.log('‚è≥ Still waiting...', { 
                        hasData: !!window.searchData, 
                        hasSchema: !!window.searchSchema 
                    });
                }
            }

            if (window.searchData && window.searchSchema) {
                console.log('üì¶ Data already loaded, initializing immediately');
                initializationAttempted = true;
                initializeSearch();
                return;
            }

            console.log('‚è≥ Waiting for data to load...');
            window.addEventListener('searchDataReady', () => {
                console.log('üì° searchDataReady event received');
                setTimeout(tryInitialize, 50);
            });

            setTimeout(() => {
                console.log('‚è∞ Timeout reached, checking status...');
                console.log('Final state check:', {
                    hasSearchData: !!window.searchData,
                    searchDataType: typeof window.searchData,
                    searchDataLength: window.searchData ? window.searchData.length : 'N/A',
                    hasSearchSchema: !!window.searchSchema,
                    searchSchemaType: typeof window.searchSchema,
                    schemaHasFacets: window.searchSchema ? !!window.searchSchema.facets : 'N/A'
                });
                
                if (!initializationAttempted) {
                    if (window.searchData && window.searchSchema) {
                        console.log('üîÑ Data available but not initialized, trying now...');
                        tryInitialize();
                    } else if (!window.searchData && !window.searchSchema) {
                        console.log('üìã No external data found, using sample data');
                        initializationAttempted = true;
                        initializeSearch();
                    } else {
                        console.error('‚ùå Partial data loading - check your file paths');
                        if (!window.searchData) {
                            document.getElementById('resultsCount').textContent = 'Error: data.js not loaded';
                        } else {
                            document.getElementById('resultsCount').textContent = 'Error: schema.js not loaded';
                        }
                    }
                }
            }, 2000);
        }

        async function initializeFromTauriDataset() {
            if (!window.__TAURI__ || !window.__TAURI__.fs) {
                return false;
            }
            const datasetPath = localStorage.getItem('linkml_browser_dataset_path');
            if (!datasetPath) {
                return false;
            }
            try {
                const { data, schema } = await loadDatasetFromPath(datasetPath);
                initializationAttempted = true;
                initializeSearch(data, schema);
                return true;
            } catch (error) {
                console.error('Failed to load dataset from path', error);
                localStorage.removeItem('linkml_browser_dataset_path');
                return false;
            }
        }

        if (window.__TAURI__) {
            initializeFromTauriDataset().then((handled) => {
                if (!handled) {
                    setupStandardInitialization();
                }
            });
        } else {
            setupStandardInitialization();
        }
    </script>
</body>
</html>
